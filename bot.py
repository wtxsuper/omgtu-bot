from datetime import datetime

from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.markdown import *
from aiogram_calendar import SimpleCalendar, get_user_locale, SimpleCalendarCallback

from api import RuzAPI
from find import find_overlap
from main import DEBUG_MODE

dp = Dispatcher()
ruz = RuzAPI()


class User(StatesGroup):
    group = State()
    date = State()
    schedule = State()
    teacher = State()


digits = ['0Ô∏è‚É£', '1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü']
weekdays = ["–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫", "–í—Ç–æ—Ä–Ω–∏–∫", "–°—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä–≥", "–ü—è—Ç–Ω–∏—Ü–∞", "–°—É–±–±–æ—Ç–∞", "–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"]


async def bot_start(BOT_TOKEN: str) -> None:
    print("–î–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –±–æ—Ç–∞ –Ω–∞–∂–º–∏—Ç–µ Ctrl + C")
    try:
        # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ —Å —Ä–µ–∂–∏–º–æ–º –ø–∞—Ä—Å–∏–Ω–≥–∞ HTML
        bot = Bot(BOT_TOKEN, parse_mode=ParseMode.HTML)
        # –ó–∞–ø—É—Å–∫ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
        await dp.start_polling(bot)
    except:
        return


@dp.message(CommandStart())
async def command_start(message: Message, state: FSMContext) -> None:
    try:
        await state.set_state(User.group)
        await message.answer(f"–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!\n"
                             f"–≠—Ç–æ –±–æ—Ç-–ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–æ–≤ –û–º–ì–¢–£. –° –º–æ–µ–π –ø–æ–º–æ—â—å—é —Ç—ã –º–æ–∂–µ—à—å "
                             f"—É–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∏–ª–∏ –Ω–∞–π—Ç–∏ –Ω—É–∂–Ω–æ–≥–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –≤ —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç–µ.\n\n"
                             f"–î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å {hbold('–≤–≤–µ–¥–∏ –Ω–æ–º–µ—Ä —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã')}. –ù–∞–ø—Ä–∏–º–µ—Ä: –ü–ò–ù-222")
    except:
        pass


@dp.message(User.group)
async def group_select(message: Message, state: FSMContext) -> None:
    try:
        selected_group = ruz.search_group(message.text)
        if not selected_group:
            await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≥—Ä—É–ø–ø—É, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!")
            return
        selected_group = selected_group[0]
        await state.update_data(group=selected_group)
        await state.set_state(User.date)
        await message.answer(f"–í—ã–±—Ä–∞–Ω–∞ –≥—Ä—É–ø–ø–∞ {selected_group['label']}!")
        await message.answer("–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É, –Ω–∞ –∫–æ—Ç–æ—Ä—É—é —Ö–æ—á–µ—à—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:", reply_markup=await SimpleCalendar(
            locale=await get_user_locale(message.from_user)).start_calendar(year=datetime.now().year,
                                                                            month=datetime.now().month))
    except:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≥—Ä—É–ø–ø—É, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!")
        return


@dp.callback_query(SimpleCalendarCallback.filter())
async def process_calendar(callback_query: CallbackQuery, callback_data: SimpleCalendarCallback,
                           state: FSMContext) -> None:
    try:
        selected, date = await SimpleCalendar(locale=await get_user_locale(callback_query.from_user)).process_selection(
            callback_query, callback_data)
        if selected:
            builder = InlineKeyboardBuilder()
            builder.add(InlineKeyboardButton(text="–î—Ä—É–≥–∞—è –¥–∞—Ç–∞ üìÖ", callback_data="date"))
            builder.add(InlineKeyboardButton(text="–°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É üîÅ", callback_data="group"))
            builder.add(InlineKeyboardButton(text="–ù–∞–π—Ç–∏ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è üîé", callback_data="find"))
            builder.adjust(1)

            await state.update_data(date=date)
            await state.set_state(User.schedule)

            # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
            state_data = await state.get_data()
            group = state_data.get("group")
            group_id = group.get('id')
            timetable = ruz.timetable_group(group_id, date)
            await state.update_data(schedule=timetable)

            # –í—ã–≤–æ–¥ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
            await callback_query.message.answer(
                f'''–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {hbold(weekdays[date.weekday()].lower())}, {hbold(date.strftime("%d.%m.%Y"))}''',
                reply_markup=builder.as_markup())
            if not timetable:
                await callback_query.message.answer("–ü–æ—Ö–æ–∂–µ, —á—Ç–æ –ø–∞—Ä –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –Ω–µ—Ç...")
            for lesson in timetable:
                answer = (
                    f"{digits[lesson.get('lessonNumberStart')]} {lesson.get('beginLesson')}-{lesson.get('endLesson')} "
                    f"{hbold(''.join([i[0] for i in lesson.get('kindOfWork').split(' ')]).upper())}\n"
                    f"{hbold(lesson.get('discipline'))}\n"
                    f"üë®‚Äçüè´ {lesson.get('lecturer')}\n"
                    f"üìç {lesson.get('auditorium')}\n"
                    f"üñáÔ∏è ")
                if lesson.get('stream'):
                    answer += lesson.get('stream')
                elif lesson.get('subGroup'):
                    answer += lesson.get('subGroup')
                else:
                    answer += group.get('label')
                await callback_query.message.answer(answer)
            await callback_query.answer()
    except:
        pass


@dp.callback_query(F.data == "group")
async def group_change(callback: CallbackQuery, state: FSMContext) -> None:
    try:
        await state.set_state(User.group)
        await callback.message.answer("–í–≤–µ–¥–∏ –Ω–æ–≤—ã–π –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã:")
        await callback.answer()
    except:
        pass


@dp.callback_query(F.data == "date")
async def group_change(callback: CallbackQuery) -> None:
    try:
        await callback.message.answer("–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É, –Ω–∞ –∫–æ—Ç–æ—Ä—É—é —Ö–æ—á–µ—à—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:",
                                      reply_markup=await SimpleCalendar(
                                          locale=await get_user_locale(callback.from_user)).start_calendar(
                                          year=datetime.now().year, month=datetime.now().month))
        await callback.answer()
    except:
        pass


@dp.callback_query(F.data == "find")
async def find_teacher(callback: CallbackQuery, state: FSMContext) -> None:
    try:
        await callback.message.answer("–í–≤–µ–¥–∏ –§–ò–û –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—á–µ—à—å –Ω–∞–π—Ç–∏:")
        await state.set_state(User.teacher)
        await callback.answer()
    except:
        pass


@dp.message(User.teacher)
async def group_select(message: Message, state: FSMContext) -> None:
    selected_teacher = ruz.search_teacher(message.text)
    if not selected_teacher:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!")
        return
    selected_teacher = selected_teacher[0]
    await state.update_data(teacher=selected_teacher)
    await state.set_state(User.date)

    builder = InlineKeyboardBuilder()
    builder.button(text="–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é üîô", callback_data="date")
    await message.answer(f"–í—ã–±—Ä–∞–Ω –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å {selected_teacher.get('label')}!", reply_markup=builder.as_markup())

    # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –∏ —Å—Ç—É–¥–µ–Ω—Ç–∞
    state_data = await state.get_data()
    date = state_data.get('date')
    teacher_schedule = ruz.timetable_teacher(selected_teacher.get('id'), date)
    student_schedule = state_data.get('schedule')

    # –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–π
    overlaps = find_overlap(student_schedule, teacher_schedule)

    if not overlaps:
        await message.answer(
            "–ü–æ—Ö–æ–∂–µ, —á—Ç–æ —è –Ω–µ –º–æ–≥—É –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Ç–µ–±–µ —É–¥–æ–±–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç... –ü–æ–ø—Ä–æ–±—É–π –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –¥–∞—Ç—É")

    # –í—ã–≤–æ–¥ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
    for oi, overlap in enumerate(overlaps):
        answer = hbold(f'–í–∞—Ä–∏–∞–Ω—Ç {oi + 1}\n') + f'–ú–æ–∂–Ω–æ –ø–æ–¥–æ–π—Ç–∏ {hunderline(overlap[0])} –ø–∞—Ä'
        await message.answer(answer)

        # –ü–∞—Ä–∞ —Å—Ç—É–¥–µ–Ω—Ç–∞
        student_lesson = overlap[1]
        student_answer = (
            f"{digits[student_lesson.get('lessonNumberStart')]} {student_lesson.get('beginLesson')}-{student_lesson.get('endLesson')} "
            f"{hbold(''.join([i[0] for i in student_lesson.get('kindOfWork').split(' ')]).upper())}\n"
            f"{hbold(student_lesson.get('discipline'))}\n"
            f"üë®‚Äçüè´ {student_lesson.get('lecturer')}\n"
            f"üìç {student_lesson.get('auditorium')}\n"
            f"üñáÔ∏è ")
        if student_lesson.get('stream'):
            student_answer += student_lesson.get('stream')
        elif student_lesson.get('subGroup'):
            student_answer += student_lesson.get('subGroup')
        else:
            student_answer += student_lesson.get('group')

        # –ü–∞—Ä–∞ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è
        teacher_lesson = overlap[2]
        teacher_answer = (
            f"{digits[teacher_lesson.get('lessonNumberStart')]} {teacher_lesson.get('beginLesson')}-{teacher_lesson.get('endLesson')} "
            f"{hbold(''.join([i[0] for i in teacher_lesson.get('kindOfWork').split(' ')]).upper())}\n"
            f"{hbold(teacher_lesson.get('discipline'))}\n"
            f"üë®‚Äçüè´ {teacher_lesson.get('lecturer')}\n"
            f"üìç {teacher_lesson.get('auditorium')}\n"
            f"üñáÔ∏è ")
        if teacher_lesson.get('stream'):
            teacher_answer += teacher_lesson.get('stream')
        elif teacher_lesson.get('subGroup'):
            teacher_answer += teacher_lesson.get('subGroup')
        else:
            teacher_answer += teacher_lesson.get('group')

        # –í—ã–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏–π
        await message.answer(hbold('–í–ê–®–ê –ü–ê–†–ê üéí\n\n') + student_answer)
        await message.answer(hbold('–ü–ê–†–ê –ü–†–ï–ü–û–î–ê–í–ê–¢–ï–õ–Ø üíº\n\n') + teacher_answer)


@dp.message(Command("debug"))
async def debug(message: Message, state: FSMContext) -> None:
    if DEBUG_MODE == "1":
        await message.answer(f"{hbold('User ID')}: {message.from_user.id}\n"
                             f"{hbold('State')}: {await state.get_state()}\n"
                             f"{hbold('DState')}: {await state.get_data()}")
    else:
        return
